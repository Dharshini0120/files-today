/* eslint-disable @typescript-eslint/no-explicit-any */
"use client";

import React, { useState, useEffect, useRef, useCallback } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import {
  Box,
  Typography,
  Button,
  Card,
  CardContent,
  LinearProgress,
  Alert,
  Chip,
  Tabs,
  Tab,
  Divider,
} from "@mui/material";
import DoneIcon from '@mui/icons-material/Done';
import HourglassBottomIcon from '@mui/icons-material/HourglassBottom';
import ArrowBackIosNewIcon from "@mui/icons-material/ArrowBackIosNew";
import ArrowForwardIosIcon from "@mui/icons-material/ArrowForwardIos";
import VisibilityIcon from "@mui/icons-material/Visibility";
import SaveOutlinedIcon from "@mui/icons-material/SaveOutlined";
import DashboardLayout from "../../../components/layout/DashboardLayout";
import QuestionInput from "../../../components/questionnaire/QuestionInput";
// import QuestionStepper from "../../../components/assessment/QuestionStepper";
import { getTemplatesData, clearTemplatesData } from '../../../utils/templatesStore';
import { useMutation } from '@apollo/client';
import { UPDATE_ASSESSMENT_MUTATION, UpdateAssessmentData, UpdateAssessmentInput } from '../../../graphql/templates.service';

interface Template {
  id: string;
  name: string;
  description: string;
  nodes: any[];
  edges: any[];
  status: string;
  createdAt: string;
  updatedAt: string;
}

const AssessmentPage = () => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const assessmentId = searchParams.get('id');
  
  console.log('üîç Assessment Form - assessmentId from URL:', assessmentId);
  
  const [template, setTemplate] = useState<Template | null>(null);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [answers, setAnswers] = useState<Record<string, any>>({});
  const [isUserSet, setIsUserSet] = useState(true);
  const [loading, setLoading] = useState(true);
  const [mounted, setMounted] = useState(false);
  const [currentSectionIndex, setCurrentSectionIndex] = useState(0);
  const [currentQuestionInSection, setCurrentQuestionInSection] = useState(0);

  const questionsTopRef = useRef<HTMLDivElement | null>(null);


  // Get templates data from store
  const [templatesData, setTemplatesDataState] = useState(getTemplatesData());
  
  // Debug store data
  console.log('üîç Store data:', { templatesData, type: typeof templatesData });

  // Assessment data state
  const [sectionVersionId, setSectionVersionId] = useState<string>('');

  // Update assessment mutation
  const [updateAssessment] = useMutation<UpdateAssessmentData>(UPDATE_ASSESSMENT_MUTATION);
  
  // Check for templates data periodically
  useEffect(() => {
    const checkTemplatesData = () => {
      const data = getTemplatesData();
      
      if (data && !templatesData) {
        console.log('üìä Found templates data in store, updating state');
        setTemplatesDataState(data);
      }
    };
    
    const interval = setInterval(checkTemplatesData, 100); // Check every 100ms
    return () => clearInterval(interval);
  }, [templatesData]);

  // Process templates and create combined template structure
  const processTemplates = useCallback(async (apiTemplates: any[]) => {
    // Remove duplicates based on template name and only keep templates with questionnaires
    const templatesWithQuestionnaires = apiTemplates.filter((template: any) => {
      // Check if template has questionnaire with nodes
      const hasQuestionnaire = template.questionnaire?.nodes &&
                             Array.isArray(template.questionnaire.nodes) &&
                             template.questionnaire.nodes.length > 0;

      if (!hasQuestionnaire) {
        console.log(` Skipping template "${template.name}" - no questionnaire data`);
        return false;
      }

      return true;
    });

    // Use a Map to deduplicate by template name (case-insensitive)
    // Also log template IDs to help debug duplicates
    const uniqueTemplatesMap = new Map();
    templatesWithQuestionnaires.forEach((template: any) => {
      const normalizedName = template.name?.trim().toLowerCase();
      if (normalizedName && !uniqueTemplatesMap.has(normalizedName)) {
        console.log(`‚úÖ Adding unique template: "${template.name}" (ID: ${template.id})`);
        uniqueTemplatesMap.set(normalizedName, template);
      } else {
        console.log(`‚ö†Ô∏è Skipping duplicate template "${template.name}" (ID: ${template.id})`);
      }
    });

    const uniqueTemplates = Array.from(uniqueTemplatesMap.values());

    console.log(`üîÑ Filtered to ${uniqueTemplates.length} unique templates with questionnaires`);

    if (uniqueTemplates.length === 0) {
      console.log('‚ùå No valid templates with questionnaires found');
      alert("No valid templates found. Please try creating a new assessment from the main page.");
      router.push("/assessment");
      return;
    }
debugger
    // Convert unique API templates into a single template with multiple sections
    const combinedTemplate: Template = {
      id: 'combined-assessment',
      name: 'Multi-Template Assessment',
      description: `Assessment with ${uniqueTemplates.length} template(s)`,
      nodes: [],
      edges: [],
      status: 'Completed',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    // Create sections for each unique template
    uniqueTemplates.forEach((apiTemplate: any, index: number) => {
      console.log(`üîÑ Processing template ${index + 1}: "${apiTemplate.name}"`);
      console.log(`üîÑ Template questionnaire nodes count:`, apiTemplate.questionnaire?.nodes?.length || 0);

      // Create a section node for this template
      const sectionNode = {
        id: `template-section-${index}`,
        type: 'sectionNode',
        position: { x: 0, y: index * 100 },
        data: {
          sectionName: apiTemplate.name, // "Ambulatory Surgical Center", "Outpatient Dialysis", etc.
          sectionVersionId: apiTemplate.id || apiTemplate._id // Store the sectionVersionId from template
        }
      };

       combinedTemplate.nodes.push(sectionNode);
      // console.log(`‚úÖ Created section node with ID: ${sectionNode.id} and name: "${sectionNode.data.sectionName}"`);

      // Add all questions from this template's questionnaire
      if (apiTemplate.questionnaire?.nodes) {
        apiTemplate.questionnaire.nodes.forEach((node: any) => {
          // Only add question nodes, skip other node types
          if (node.type === 'questionNode') {
            // Prefix node IDs to avoid conflicts between templates
            const prefixedNode = {
              ...node,
             id: `template-${index}-${node.id}`,
              //id: node.id,
              data: {
                ...node.data,
                templateSection: `template-section-${index}` // Link to section
              }
            };
            combinedTemplate.nodes.push(prefixedNode);
          }
        });
      }
debugger
      // Add edges from this template's questionnaire
      if (apiTemplate.questionnaire?.edges) {
        apiTemplate.questionnaire.edges.forEach((edge: any) => {
          // Prefix edge IDs to avoid conflicts
          const prefixedEdge = {
            ...edge,
            id: `template-${index}-${edge.id}`,
            source: `template-${index}-${edge.source}`,
            target: `template-${index}-${edge.target}`
          };
          combinedTemplate.edges.push(prefixedEdge);
        });
      }
    });

    console.log('üîÑ Combined template:', combinedTemplate);
    console.log('üîÑ Number of sections:', uniqueTemplates.length);
    console.log('üîÑ Total nodes:', combinedTemplate.nodes.length);

    setTemplate(combinedTemplate);
    setLoading(false);
  }, [router]);

  // Load templates from context data when component mounts
  useEffect(() => {
    console.log('üîÑ useEffect triggered:', { mounted, isUserSet, templatesData: !!templatesData });
    if (!mounted || !isUserSet) return;
    
    if (!templatesData) {
      console.log('‚ùå No templates data available, redirecting to assessment page');
      router.push("/assessment");
      return;
    }

    const loadTemplateFromContextData = async () => {
      try {
        console.log('üîÑ Loading template from context data...');
        console.log('üìä Templates data received:', templatesData);

        // Check if we're editing an existing assessment
        if (templatesData.isEditing && templatesData.assessment) {
          // Create a template from the existing assessment data
          const assessmentData = templatesData.assessment;
          
          // Ensure assessmentData has the expected structure
          if (!assessmentData.sections || !Array.isArray(assessmentData.sections)) {
            alert("Invalid assessment data. Please try again.");
            router.push("/assessment");
            return;
          }
          
          // Convert assessment sections to template format
          const formattedTemplates = assessmentData.sections.map((section: any, index: number) => {            
            return {
              id: section.sectionId || `section-${index}`,
              name: section.sectionName || `Section ${index + 1}`,
              questionnaire: section.questionnaire || { nodes: [], edges: [] },
              version: '1.0', // Default version for existing assessments
              facilityandservicelines: [],
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
              isExistingAssessment: true,
              answers: section.answers || [],
              progress: section.progress || {
                currentQuestionIndex: 0,
                totalQuestionsInSection: 0,
                answeredQuestionsInSection: 0
              }
            };
          });
          // Process the templates (this will handle the existing assessment data)
          await processTemplates(formattedTemplates);
          
          // Set the current section and question based on progress
          if (assessmentData.overallProgress) {
            setCurrentSectionIndex(assessmentData.overallProgress.currentSectionIndex || 0);
            setCurrentQuestionInSection(assessmentData.overallProgress.currentQuestionIndex || 0);
          }
          
          // Load existing answers if available
          if (assessmentData.sections) {
            const existingAnswers: Record<string, any> = {};
            assessmentData.sections.forEach((section: any) => {
              if (section.answers && Array.isArray(section.answers)) {
                section.answers.forEach((answer: any) => {
                  if (answer.questionId && answer.value !== undefined) {
                    existingAnswers[answer.questionId] = answer.value;
                  }
                });
              }
            });
            setAnswers(existingAnswers);
          }
          
          return;
        }

        // Use the data from the context for new assessments
        const apiTemplates = templatesData.scenarioVersions || [];
        const assessmentData = templatesData.assessment;

        console.log('üìä Assessment data:', assessmentData);
        console.log('üìä Scenario versions:', apiTemplates);

        // Filter for active templates with questionnaire data
        const availableTemplates = apiTemplates.filter(
          (template) =>
            template.status === 'ACTIVE' &&
            template.isLatest &&
            template.questionnaire &&
            template.questionnaire.nodes &&
            Array.isArray(template.questionnaire.nodes) &&
            template.questionnaire.nodes.length > 0
        );

        if (availableTemplates.length === 0) {
          console.log('‚ùå No active templates with questionnaires found from context');
          alert("No templates available for assessment. Please contact your administrator.");
          router.push("/assessment");
          return;
        }

        // Convert API templates to the format expected by the assessment page
        const formattedTemplates = availableTemplates.map(template => ({
          id: template._id,
          name: template.scenario.name,
          questionnaire: template.questionnaire,
          version: template.version,
          facilityandservicelines: template.facilityandservicelines,
          createdAt: template.createdAt,
          updatedAt: template.updatedAt
        }));

        console.log('‚úÖ Successfully loaded templates from context data:', formattedTemplates.length);
        console.log('üîÑ Template names found:', formattedTemplates.map((t: any) => t.name));

        // If there's existing assessment data, load the progress
        if (assessmentData && assessmentData.questionnaire) {
          console.log('üìä Loading existing assessment progress...');
          // Extract assessment data for updates
          
          // Extract section version ID from the first section
          if (assessmentData.questionnaire.length > 0) {
            setSectionVersionId(assessmentData.questionnaire[0].sectionVersionId);
          }
          
          // You can use assessmentData.questionnaire to restore previous answers
          // and assessmentData.overallProgress to show current progress
        } else {
          // Set default values for new assessment
          // Assessment ID comes from URL parameter
        }

        // Process the templates
        await processTemplates(formattedTemplates);

      } catch (e) {
        console.error("‚ùå Error loading template from context data:", e);
        alert("Failed to load template");
        router.push("/dashboard");
      }
    };

    loadTemplateFromContextData();
  }, [templatesData, router, processTemplates, mounted, isUserSet]);

  useEffect(() => {
    setMounted(true);
    setIsUserSet(true);
  }, []);

  // Fallback timeout to handle cases where templates data is not available
  useEffect(() => {
    const timeout = setTimeout(() => {
      if (!templatesData && mounted && isUserSet) {
        console.log('‚è∞ Timeout reached, no templates data available, redirecting to assessment page');
        router.push("/assessment");
      }
    }, 10000); // 10 second timeout

    return () => clearTimeout(timeout);
  }, [templatesData, mounted, isUserSet, router]);

  // Cleanup templates data when component unmounts
  useEffect(() => {
    return () => {
      clearTemplatesData();
    };
  }, []);

  const handleAnswerChange = (questionId: string, answer: any) => {
    setAnswers((prev) => ({ ...prev, [questionId]: answer }));
    setTimeout(() => {
      const visible = getQuestionNodes();
      if (currentQuestionIndex >= visible.length && visible.length > 0) {
        setCurrentQuestionIndex(visible.length - 1);
      }
    }, 0);
  };

  // Function to update assessment
  const handleUpdateAssessment = async (isCompleted: boolean = false) => {
    // Get assessmentId from URL (for edit) or from store (for new)
    const currentAssessmentId = assessmentId || templatesData?.assessment?._id;
    
    console.log('üîç Assessment ID sources:', {
      fromURL: assessmentId,
      fromStore: templatesData?.assessment?._id,
      currentAssessmentId,
      templatesData: templatesData
    });
    
    if (!currentAssessmentId) {
      console.log('No assessmentId found - this is a new assessment, skipping update for now');
      return;
    }

    try {
      console.log('üîÑ Updating assessment...');
      
      // Get current answers
      const currentAnswers = Object.entries(answers).map(([questionId, answer]) => ({
        questionId,
        answer: answer || '',
        answeredAt: new Date().toISOString()
      }));

      // // Calculate progress 
       const questionNodes = getQuestionNodes();
      const currentSectionQuestions = getCurrentSectionQuestions();
       const totalQuestions = questionNodes.length;
      const answeredQuestions = currentAnswers.length;
      const overallProgress = calculateWeightedProgress()

      // Create questionnaire sections for all sections
      const sections = getSections();
      const questionnaireSections = sections.map((section: any) => {
        // Get answers for this specific section
        const sectionAnswers = Object.entries(answers)
          .filter(([questionId, answer]) => {
            // Check if this question belongs to this section
            const question = template?.nodes.find(n => n.id === questionId);
            return question?.data?.templateSection === section.id;
          })
          .map(([questionId, answer]) => ({
            questionId,
            answer: answer || '',
            answeredAt: new Date().toISOString()
          }));

        // Get questions for this section
        const sectionQuestions = section.questions || [];
        
        return {
          sectionVersionId: section.data?.sectionVersionId || sectionVersionId || '68b18619e0337e146a5230bf',
          answers: sectionAnswers,
          progress: {
            currentQuestionIndex: section.id === sections[currentSectionIndex]?.id ? currentQuestionInSection : 0,
            totalQuestionsInSection: sectionQuestions.length,
            answeredQuestionsInSection: sectionAnswers.length
          }
        };
      });

      // Create overall progress -wrong
      const overallProgressData = {
        currentSectionIndex: currentSectionIndex,
        totalSections: template?.nodes?.filter(node => node.type === 'sectionNode').length || 1,
        overallProgress,
        totalQuestions,
        answeredQuestions
      };

      // Determine status
      let status = 'inProgress';
      
      if (isCompleted) {
        // Final submit - check ALL answers for "Refer to Consultant"
        const questionNodes = getQuestionNodes();
        let hasReferToConsultant = false;
        
        for (const question of questionNodes) {
          const answer = answers[question.id];
          if (answer) {
            // Check if answer contains "refer to consultant" (case insensitive)
            const answerStr = Array.isArray(answer) ? answer.join(' ') : answer;
            if (answerStr && answerStr.toLowerCase().includes('refer to consultant')) {
              hasReferToConsultant = true;
              break;
            }
          }
        }
        
        if (hasReferToConsultant) {
          status = 'blocked';
          console.log('üö´ Final submit: Status set to BLOCKED due to "Refer to Consultant" answer');
        } else {
          status = 'completed';
          console.log('‚úÖ Final submit: Status set to COMPLETED');
        }
      } else {
        // During assessment (Next Question) - always set to inProgress to allow continuing
        status = 'inProgress';
        console.log('üîÑ During assessment: Status set to IN_PROGRESS (allowing continuation)');
      }

      const updateInput: UpdateAssessmentInput = {
        questionnaire: questionnaireSections,
        status,
        overallProgress: overallProgressData
      };

      console.log('üìä Update input:', updateInput);

      const result = await updateAssessment({
        variables: {
          assessmentId: currentAssessmentId,
          input: updateInput
        }
      });

      console.log('‚úÖ Assessment updated successfully:', result.data);
      
      if (result.data?.updateAssessment.status === 'success') {
        // Update local state with the response
        
        if (isCompleted) {
          // Redirect to assessment list or show completion message
          router.push('/assessment');
        }
      }

    } catch (error) {
      console.error('‚ùå Error updating assessment:', error);
    }
  };

  const handleNextSection = async () => {
    const sections = getSections();
    if (currentSectionIndex < sections.length - 1) {
      // Update assessment before moving to next section
      await handleUpdateAssessment(false);
      
      setCurrentSectionIndex((p) => p + 1);
      setCurrentQuestionInSection(0); // Reset to first question in new section
      questionsTopRef.current?.scrollIntoView({ behavior: "smooth", block: "start" });
    }
  };


  const handleNextQuestion = async () => {
    const sections = getSections();
    const currentSection = sections[currentSectionIndex];
    if (!currentSection) return;

    // Update assessment before moving to next question
    await handleUpdateAssessment(false);

    const sectionQuestions = currentSection.questions;
    if (currentQuestionInSection < sectionQuestions.length - 1) {
      // Move to next question in current section
      setCurrentQuestionInSection(prev => prev + 1);
    } else {
      // Last question in section, move to next section
      handleNextSection();
    }
    questionsTopRef.current?.scrollIntoView({ behavior: "smooth", block: "start" });
  };

  const handlePreviousQuestion = () => {
    if (currentQuestionInSection > 0) {
      // Move to previous question in current section
      setCurrentQuestionInSection(prev => prev - 1);
    } else if (currentSectionIndex > 0) {
      // First question in section, move to last question of previous section
      const sections = getSections();
      const previousSection = sections[currentSectionIndex - 1];
      if (previousSection) {
        setCurrentSectionIndex(prev => prev - 1);
        setCurrentQuestionInSection(previousSection.questions.length - 1);
      }
    }
    questionsTopRef.current?.scrollIntoView({ behavior: "smooth", block: "start" });
  };
  const handleSaveDraft = () => {
    console.log("Saving draft...", answers);
    // Just redirect to assessment page without API call
    router.push('/assessment');
  };
  const handleSubmitAssessment = async () => {
    // Save current state before navigating to review
    localStorage.setItem('assessmentAnswers', JSON.stringify(answers));
    localStorage.setItem('assessmentSections', JSON.stringify(sections));
    
    // Update assessment as inProgress (not completed yet) - allows continuation
    await handleUpdateAssessment(false);
    
    // Navigate to review page
    router.push('/assessment/review');
  };

  // ---------------- FLOW / ORDERING / VISIBILITY HELPERS ----------------

  const isQuestionNode = (n: any) =>
    n?.type === "questionNode" &&
    n?.data?.question &&
    ["radio", "checkbox", "text-input", "multiple-choice", "yes-no"].includes(
      n?.data?.questionType
    );

  const parseQId = (id: string) => {
    // Handle template-based IDs like "template-0-1", "template-0-2", etc.
    const templateMatch = String(id).trim().match(/^template-\d+-(\d+)([a-z])?$/i);
    if (templateMatch) {
      const num = parseInt(templateMatch[1], 10);
      const suf = templateMatch[2] ? templateMatch[2].toLowerCase() : "";
      return { num, suf };
    }
    
    // Handle traditional IDs like "q1", "q2", etc.
    const m = String(id).trim().match(/^q(\d+)([a-z])?$/i);
    const num = m ? parseInt(m[1], 10) : Number.MAX_SAFE_INTEGER;
    const suf = m && m[2] ? m[2].toLowerCase() : "";
    return { num, suf };
  };
  const sortQuestions = (a: any, b: any) => {
    const A = parseQId(a.id);
    const B = parseQId(b.id);
    if (A.num !== B.num) return A.num - B.num;
    if (A.suf !== B.suf) return A.suf.localeCompare(B.suf);
    if (a.position?.y !== b.position?.y) return (a.position?.y ?? 0) - (b.position?.y ?? 0);
    return (a.position?.x ?? 0) - (b.position?.x ?? 0);
  };

  const getAllQuestionNodesInSection = () => {
    if (!template?.nodes) return [];
    return template.nodes.filter(isQuestionNode).slice().sort(sortQuestions);
  };

  const getFirstQuestionInSection = (sectionId: string) => {
    if (!template) return null;
    const startEdge = template.edges.find((e) => e.source === sectionId && e.target);
    const startNode = startEdge
      ? template.nodes.find((n) => n.id === startEdge.target)
      : null;
    if (startNode && isQuestionNode(startNode)) return startNode;
    const all = getAllQuestionNodesInSection();
    return all[0] ?? null;
  };

  const checkEdgeCondition = (edge: any, answer: any) => {
    if (edge?.sourceHandle === "text-output" || edge?.data?.condition === "text-input") {
      return String(answer ?? "").trim() !== "";
    }

    const expected: string[] = [];

    // Collect all possible expected values for this edge
    if (edge?.data?.optionText) expected.push(edge.data.optionText);

    const sourceNode = template?.nodes.find((n) => n.id === edge.source);
    const m = edge?.sourceHandle?.match(/option-(\d+)/);
    if (m && sourceNode?.data?.options) {
      const idx = parseInt(m[1], 10);
      const opt = sourceNode.data.options[idx];
      if (opt) expected.push(opt);
    }

    if (edge?.label) expected.push(edge.label);

    // Check if answer matches any expected value
    let matches = false;
    if (Array.isArray(answer)) {
      matches = answer.some((a) => expected.includes(a));
    } else {
      matches = expected.includes(answer);
    }

    console.log(`üîç Edge condition check: answer="${answer}", expected=[${expected.join(', ')}], matches=${matches}`);
    return matches;
  };

  // Check if a section is completed (all questions answered)
  const isSectionCompleted = (sectionId: string): boolean => {
    const section = sections.find((s: any) => s.id === sectionId);
    if (!section) return false;

    const sectionQuestions = section.questions || [];
    if (sectionQuestions.length === 0) return true;

    // Check if all questions in the section have answers
    return sectionQuestions.every((question: any) => {
      const answer = answers[question.id];
      return answer !== undefined && answer !== null && answer !== "";
    });
  };

  const getEndActionForAnswer = (sourceId: string, answer: any): string | null => {
    if (!template || answer === undefined || answer === null || answer === "") return null;
    const outgoing = template.edges.filter((e) => e.source === sourceId);

    console.log(`üîç Checking end action for question ${sourceId} with answer "${answer}"`);
    console.log(`üîç Found ${outgoing.length} outgoing edges:`, outgoing.map(e => ({
      target: e.target,
      optionText: e.data?.optionText || e.label,
      sourceHandle: e.sourceHandle
    })));

    // Check if there's a matching edge for this answer
    let hasMatchingEdge = false;
    let hasMatchingEdgeWithTarget = false;

    for (const e of outgoing) {
      if (checkEdgeCondition(e, answer)) {
        hasMatchingEdge = true;
        console.log(`‚úÖ Found matching edge for "${answer}":`, {
          target: e.target,
          optionText: e.data?.optionText || e.label,
          hasTarget: !!e.target
        });

        // If the edge has no target, it's an end action
        if (!e.target) {
          const endAction = e.data?.endAction || e.label || "Refer to Consultant";
          console.log(`üîö End action triggered: ${endAction}`);
          return endAction;
        } else {
          hasMatchingEdgeWithTarget = true;
        }
      }
    }

    // If we found a matching edge but it has no target, or no matching edge at all
    if (hasMatchingEdge && !hasMatchingEdgeWithTarget) {
      console.log(`üîÑ Matching edge found but no target - referring to consultant`);
      return "Refer to Consultant";
    }

    // If no matching edge found for this answer, it means this option has no next question
    if (!hasMatchingEdge && answer) {
      console.log(`üîÑ No matching edge found for question ${sourceId} with answer "${answer}" - referring to consultant`);
      return "Refer to Consultant";
    }

    return null;
  };

  const getReachableQuestions = (sectionId: string) => {
    if (!template?.nodes || !template?.edges) return [];

    const start = getFirstQuestionInSection(sectionId);
    if (!start) return [];

    const visited = new Set<string>();
    const queue: string[] = [start.id];

    while (queue.length) {
      const nodeId = queue.shift()!;
      if (visited.has(nodeId)) continue;
      visited.add(nodeId);

      const nodeAnswer = answers[nodeId];
      const outgoing = template.edges.filter((e) => e.source === nodeId);

      if (nodeAnswer === undefined || nodeAnswer === null || nodeAnswer === "") {
        outgoing
          .filter((e) => e.target)
          .forEach((e) => {
            if (e.target && !visited.has(e.target)) queue.push(e.target);
          });
      } else {
        const matched = outgoing.filter((e) => checkEdgeCondition(e, nodeAnswer));
        const hasEnd = matched.some((e) => !e.target);
        if (!hasEnd) {
          matched.forEach((e) => {
            if (e.target && !visited.has(e.target)) queue.push(e.target);
          });
        }
      }
    }

    const nodes = Array.from(visited)
      .map((id) => template.nodes.find((n) => n.id === id))
      .filter(Boolean)
      .filter(isQuestionNode) as any[];

    nodes.sort(sortQuestions);
    return nodes;
  };

  const getQuestionsForSection = (sectionId: string) => {
    if (!template?.nodes) return [];

    // For template-based sections, implement proper navigation logic
    if (sectionId.startsWith('template-section-')) {
      // Get all questions that belong to this template section
      const allSectionQuestions = template.nodes
        .filter((node) =>
          isQuestionNode(node) &&
          node.data?.templateSection === sectionId
        )
        .sort(sortQuestions);

      if (allSectionQuestions.length === 0) return [];

      // Find the first question in this section
      const firstQuestion = allSectionQuestions[0];
      if (!firstQuestion) return [];

      // Use the reachable questions logic starting from the first question
      const visited = new Set<string>();
      const queue: string[] = [firstQuestion.id];
      const reachableQuestions: any[] = [];

      while (queue.length) {
        const nodeId = queue.shift()!;
        if (visited.has(nodeId)) continue;
        visited.add(nodeId);

        // Find the actual node
        const node = template.nodes.find(n => n.id === nodeId);
        if (node && isQuestionNode(node) && node.data?.templateSection === sectionId) {
          reachableQuestions.push(node);
        }

        const nodeAnswer = answers[nodeId];
        const outgoing = template.edges.filter((e) => e.source === nodeId);

        if (nodeAnswer === undefined || nodeAnswer === null || nodeAnswer === "") {
          // If no answer yet, show all possible next questions
          outgoing
            .filter((e) => e.target)
            .forEach((e) => {
              if (e.target && !visited.has(e.target)) {
                const targetNode = template.nodes.find(n => n.id === e.target);
                if (targetNode && targetNode.data?.templateSection === sectionId) {
                  queue.push(e.target);
                }
              }
            });
        } else {
          // If answered, follow the matching edges
          const matched = outgoing.filter((e) => checkEdgeCondition(e, nodeAnswer));
          const hasEnd = matched.some((e) => !e.target);
          if (!hasEnd) {
            matched.forEach((e) => {
              if (e.target && !visited.has(e.target)) {
                const targetNode = template.nodes.find(n => n.id === e.target);
                if (targetNode && targetNode.data?.templateSection === sectionId) {
                  queue.push(e.target);
                }
              }
            });
          }
        }
      }

      console.log(`üîç Section ${sectionId}: Found ${reachableQuestions.length} reachable questions`);
      return reachableQuestions.sort(sortQuestions);
    }

    // For traditional sections, use the existing reachable questions logic
    return getReachableQuestions(sectionId);
  };

  const getSections = () => {
    if (!template?.nodes) return [];
    const sections = template.nodes
      .filter((n) => n.type === "sectionNode" && n.data?.sectionName)
      .sort((a, b) => {
        // Handle both traditional section-X and template-section-X formats
        const aNum = a.id.startsWith('template-section-')
          ? parseInt(a.id.replace('template-section-', ''), 10)
          : parseInt(String(a.id).replace("section-", ""), 10);
        const bNum = b.id.startsWith('template-section-')
          ? parseInt(b.id.replace('template-section-', ''), 10)
          : parseInt(String(b.id).replace("section-", ""), 10);
        return (isNaN(aNum) ? 9999 : aNum) - (isNaN(bNum) ? 9999 : bNum);
      });

    console.log('üîç Found sections:', sections.map(s => ({ id: s.id, name: s.data?.sectionName })));

    return sections.map((section) => ({
      ...section,
      questions: getQuestionsForSection(section.id),
    }));
  };

  const getQuestionNodes = () => {
    const sec = getSections();
    return sec.flatMap((s: any) => s.questions);
  };

  const handleSectionChange = (i: number) => {
    setCurrentSectionIndex(i);
    setCurrentQuestionInSection(0); // Reset to first question in new section
    questionsTopRef.current?.scrollIntoView({ behavior: "smooth", block: "start" });
  };

  // Helper functions for single question display
  const getCurrentQuestion = () => {
    const sections = getSections();
    const currentSection = sections[currentSectionIndex];
    if (!currentSection || !currentSection.questions) return null;
    return currentSection.questions[currentQuestionInSection] || null;
  };

  const getCurrentSectionQuestions = () => {
    const sections = getSections();
    const currentSection = sections[currentSectionIndex];
    return currentSection?.questions || [];
  };

  const getAnsweredQuestionsInCurrentSection = () => {
    const sectionQuestions = getCurrentSectionQuestions();
    const answeredIndices = new Set<number>();
    sectionQuestions.forEach((question, index) => {
      if (answers[question.id] !== undefined && answers[question.id] !== null && answers[question.id] !== '') {
        answeredIndices.add(index);
      }
    });
    return answeredIndices;
  };

  const isFirstQuestion = () => {
    return currentSectionIndex === 0 && currentQuestionInSection === 0;
  };

  const isLastQuestion = () => {
    const sections = getSections();
    const isLastSection = currentSectionIndex === sections.length - 1;
    const currentSection = sections[currentSectionIndex];
    const isLastQuestionInSection = currentSection && currentQuestionInSection === currentSection.questions.length - 1;
    return isLastSection && isLastQuestionInSection;
  };

  const isLastQuestionInSection = () => {
    const currentSection = getSections()[currentSectionIndex];
    return currentSection && currentQuestionInSection === currentSection.questions.length - 1;
  };

  const isCurrentQuestionAnswered = () => {
    const currentQuestion = getCurrentQuestion();
    if (!currentQuestion) return false;

    const answer = answers[currentQuestion.id];
    return answer !== undefined && answer !== null && answer !== '';
  };

  const handleQuestionClick = (questionIndex: number) => {
    setCurrentQuestionInSection(questionIndex);
    questionsTopRef.current?.scrollIntoView({ behavior: "smooth", block: "start" });
  };

  // ---------------- PROGRESS & STATUS ----------------

  const calculateWeightedProgress = () => {
    const sections = getSections();
    if (sections.length === 0) return 0;

    let totalWeightedCompletion = 0;
    let totalWeight = 0;

    sections.forEach((section: any) => {
      const sectionWeight = 1;
      const sectionQuestions = section.questions;

      if (sectionQuestions.length === 0) {
        totalWeight += sectionWeight;
        return;
      }

      const answeredQuestions = sectionQuestions.filter((q: any) => !!answers[q.id]);
      const sectionCompletion = (answeredQuestions.length / sectionQuestions.length) * 100;

      totalWeightedCompletion += sectionCompletion * sectionWeight;
      totalWeight += sectionWeight;
    });

    const weightedAverage = totalWeight > 0 ? totalWeightedCompletion / totalWeight : 0;
    return Math.round(weightedAverage);
  };

  useEffect(() => {
    if (!template?.nodes || !template?.edges || !isUserSet) return;
    const visibleQuestions = getQuestionNodes();
    if (currentQuestionIndex >= visibleQuestions.length && visibleQuestions.length > 0) {
      setCurrentQuestionIndex(visibleQuestions.length - 1);
    }
  }, [answers, template, isUserSet, currentQuestionIndex]);

  // Reset question index when section changes
  useEffect(() => {
    setCurrentQuestionInSection(0);
  }, [currentSectionIndex]);

  // Ensure current question index is valid for the current section
  useEffect(() => {
    const currentSectionQuestions = getCurrentSectionQuestions();
    if (currentQuestionInSection >= currentSectionQuestions.length && currentSectionQuestions.length > 0) {
      setCurrentQuestionInSection(currentSectionQuestions.length - 1);
    }
  }, [currentSectionIndex, currentQuestionInSection, template]);

  if (!mounted) return null;

  // Debug logging
  console.log('üîÑ Render state:', { loading, templatesData: !!templatesData, template: !!template });

  // If we have templates data but no template yet, we're still processing
  if (loading || (templatesData && !template)) {
    return (
      <DashboardLayout>
        <Box
          sx={{
            minHeight: "100vh",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: "#fafafa",
          }}
        >
          <Card sx={{ p: 4, textAlign: "center", maxWidth: 400 }}>
            <CardContent>
              <Typography variant="h6" sx={{ mb: 2, color: "#6b7280" }}>
                Loading Assessment...
              </Typography>
              <Typography variant="body2" sx={{ mb: 2, color: "#9ca3af" }}>
                {templatesData ? 'Processing templates...' : 'Waiting for templates data...'}
              </Typography>
              <Typography variant="caption" sx={{ mb: 2, color: "#6b7280", display: 'block' }}>
                Debug: mounted={mounted ? 'true' : 'false'}, isUserSet={isUserSet ? 'true' : 'false'}, hasTemplatesData={templatesData ? 'true' : 'false'}
              </Typography>
              <LinearProgress sx={{ mt: 2 }} />
            </CardContent>
          </Card>
        </Box>
      </DashboardLayout>
    );
  }

  // If we don't have templates data and we're not loading, redirect to assessment page
  if (!templatesData && !loading) {
    console.log('‚ùå No templates data available, redirecting to assessment page');
    router.push("/assessment");
    return null;
  }

  const questionNodes = getQuestionNodes();
  const currentQuestion = questionNodes[currentQuestionIndex];
  const progress = calculateWeightedProgress();

  if (!currentQuestion) {
    return (
      <DashboardLayout
      >
        <Box
          sx={{
            minHeight: "100vh",
            backgroundColor: "#fafafa",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          }}
        >
          <Card sx={{ p: 4, textAlign: "center" }}>
            <Typography variant="h6" color="error">
              No questions found in this template
            </Typography>
            <Button onClick={() => router.push("/dashboard")} sx={{ mt: 2 }}>
              Back to Dashboard
            </Button>
          </Card>
        </Box>
      </DashboardLayout>
    );
  }

  const sections = getSections();

  return (
    <DashboardLayout
    >
      <Box sx={{ height: "100%", backgroundColor: "#f8fafc", overflow: "auto" }}>
        {/* Sticky Header */}
        <Box sx={{ backgroundColor: "transparent", position: "sticky", top: 0, zIndex: 10 }}>
          <Box sx={{ px: 0, pt: 0, pb: 1, display: "flex", justifyContent: "space-between", alignItems: "center" }}>
            <Box>
              <Typography variant="h5" fontWeight={600} fontFamily={"var(--font-inter), sans-serif"} sx={{ color: "#111827" }}>
                {templatesData?.isEditing ? 'Edit Assessment' : 'New Assessment'}
              </Typography>
              <Typography variant="subtitle1" color="#6c757d" fontFamily={"var(--font-inter), sans-serif"}>
                {sections[currentSectionIndex]?.data?.sectionName || "Assessment"} - Started on{" "}
                {new Date().toLocaleDateString("en-US", { month: "short", day: "2-digit", year: "numeric" })}
              </Typography>
            </Box>
            <Chip
              label={`In Progress - ${progress}%`}
              sx={{
                backgroundColor: "#faf5e3",
                color: "#e9b825",
                fontWeight: 700,
                borderRadius: "8px",
                px: 1.5,
                height: 32,
              }}
            />
          </Box>

          <Box sx={{ px: 0, pb: 0 }}>
            <LinearProgress
              variant="determinate"
              value={progress}
              sx={{
                height: 6,
                borderRadius: 3,
                backgroundColor: "#e5e7eb",
                "& .MuiLinearProgress-bar": { backgroundColor: "#3b82f6", borderRadius: 3 },
              }}
            />
          </Box>
        </Box>

        <Box ref={questionsTopRef} />

        <Card
          variant="outlined"
          sx={{
            borderColor: "#e5e7eb",
            borderRadius: 2,
            boxShadow: "0 1px 2px rgba(0,0,0,0.04)",
            mt: 2,
            display: "flex",
            flexDirection: "column",
          }}
        >
          {/* Tabs header (unchanged) */}
          <Box sx={{ px: 2, pt: 1.5, bgcolor: "#fff" }}>
            <Tabs
              value={currentSectionIndex}
              onChange={(_, v) => handleSectionChange(v)}
              variant="fullWidth"
              TabIndicatorProps={{
                sx: {
                  height: 3,
                  borderRadius: 2,
                  backgroundColor: "#3a7de6" // Always blue for active tab
                }
              }}
              sx={{
                px: 0,
                "& .MuiTabs-flexContainer": { width: "100%" },
                "& .MuiTab-root": {
                  minWidth: 0,
                  flex: 1,
                  width: "100%",
                  textTransform: "none",
                  fontWeight: 600,
                  color: "#6b6b6b",
                  minHeight: 44,
                  "&.Mui-selected": {
                    color: "#000000",
                    backgroundColor: "#f5f9ff",
                    borderRadius: "8px 8px 0 0",
                    fontWeight: 700,
                  },
                },
              }}
            >
              {sections.map((section: any, index: number) => {
                const isCompleted = isSectionCompleted(section.id);
                const isSelected = currentSectionIndex === index;

                return (
                  <Tab
                    key={section.id}
                    disableRipple
                    label={
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        {/* Show icon only for non-selected tabs */}
                        {!isSelected && (
                          <>
                            {isCompleted ? (
                              <DoneIcon
                                sx={{
                                  fontSize: 18,
                                  color: "#4cb054"
                                }}
                              />
                            ) : (
                              <HourglassBottomIcon
                                sx={{
                                  fontSize: 18,
                                  color: "#e9b825"
                                }}
                              />
                            )}
                          </>
                        )}
                        <Typography
                          sx={{
                            fontSize: '14px',
                            fontWeight: isSelected ? 700 : 600,
                            color: isSelected
                              ? "#000000" // Blue for active tab
                              : isCompleted
                                ? "#4cb054" // Green for completed inactive tabs
                                : "#e9b825", // Yellow for incomplete inactive tabs
                            textTransform: 'none',
                          }}
                        >
                          {section.data.sectionName}
                        </Typography>
                      </Box>
                    }
                  />
                );
              })}
            </Tabs>
          </Box>

          <Divider sx={{ borderColor: "#e5e7eb" }} />

          <CardContent
            sx={{
              p: 2.5,
              pt: 3,
              maxHeight: "calc(100vh - 320px)",
              overflowY: "auto",
              pr: 2,
              ml: 3,
              "&::-webkit-scrollbar": { width: 8 },
              "&::-webkit-scrollbar-track": { backgroundColor: "#e5e7eb", borderRadius: 8 },
              "&::-webkit-scrollbar-thumb": { backgroundColor: "#3b82f6", borderRadius: 8 },
              scrollbarColor: "#3b82f6 #e5e7eb",
            }}
          >
            {/* Question Stepper */}
            {/* <QuestionStepper
              totalQuestions={getCurrentSectionQuestions().length}
              currentQuestionIndex={currentQuestionInSection}
              answeredQuestions={getAnsweredQuestionsInCurrentSection()}
              sectionName={sections[currentSectionIndex]?.data?.sectionName || ""}
              onQuestionClick={handleQuestionClick}
            /> */}

            {/* Current Question Display */}
            {(() => {
              const currentQuestion = getCurrentQuestion();
              if (!currentQuestion) {
                return (
                  <Box sx={{ textAlign: 'center', py: 4 }}>
                    <Typography variant="h6" color="text.secondary">
                      No questions available in this section
                    </Typography>
                  </Box>
                );
              }

              const endActionMsg = getEndActionForAnswer(currentQuestion.id, answers[currentQuestion.id]);

              return (
                <Box sx={{ my: 6 }}>
                  <Typography
                    sx={{
                      fontSize: "18px",
                      fontWeight: 600,
                      mb: 2,
                      mt: 2,
                      color: "#1f2937",
                      lineHeight: 1.5,
                    }}
                  >
                    {currentQuestionInSection + 1}. {currentQuestion.data.question}
                    {currentQuestion.data.isRequired && <span style={{ color: "#ef4444" }}> *</span>}
                  </Typography>

                  <QuestionInput
                    question={currentQuestion}
                    answer={answers[currentQuestion.id]}
                    onAnswerChange={(answer) => handleAnswerChange(currentQuestion.id, answer)}
                  />

                  {endActionMsg && (
                    <Alert severity="info" sx={{ mt: 3 }}>
                      {endActionMsg}
                    </Alert>
                  )}
                </Box>
              );
            })()}
          </CardContent>

          <Divider sx={{ borderColor: "#e5e7eb" }} />

          <Box
            sx={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              px: 2.5,
              py: 2,
              bgcolor: "#fff",
            }}
          >
            {/* Left side - Previous Question button */}
            <Button
              onClick={handlePreviousQuestion}
              disabled={isFirstQuestion()}
              variant="outlined"
              startIcon={<ArrowBackIosNewIcon />}
              sx={{
                textTransform: "none",
                fontWeight: 700,
                borderRadius: "10px",
                borderWidth: 2,
                px: 2.5,
                py: 1,
                borderColor: "#e5e7eb",
                color: "#6b7280",
                "&:hover": { borderColor: "#d1d5db", background: "#f9fafb" },
                "&.Mui-disabled": { borderColor: "#e5e7eb", color: "#d1d5db" },
              }}
            >
              Previous Question
            </Button>

            {/* Right side - Save Draft and Next/Review buttons */}
            <Box sx={{ display: "flex", gap: 2 }}>
              <Button
                onClick={handleSaveDraft}
                variant="outlined"
                startIcon={<SaveOutlinedIcon />}
                sx={{
                  textTransform: "none",
                  fontWeight: 700,
                  borderRadius: "10px",
                  borderWidth: 2,
                  px: 2.5,
                  py: 1,
                  color: "#3b82f6",
                  borderColor: "#3b82f6",
                  "&:hover": { borderColor: "#2f6fe0", background: "rgba(59,130,246,0.06)" },
                }}
              >
                {templatesData?.isEditing ? 'Save Changes' : 'Save as Draft'}
              </Button>

              {isLastQuestion() ? (
                <Button
                  onClick={handleSubmitAssessment}
                  disabled={!isCurrentQuestionAnswered()}
                  variant="contained"
                  endIcon={<VisibilityIcon />}
                  sx={{
                    textTransform: "none",
                    fontWeight: 700,
                    borderRadius: "10px",
                    px: 2.8,
                    py: 1.1,
                    background: !isCurrentQuestionAnswered() ? "#d1d5db" : "#3b82f6",
                    color: !isCurrentQuestionAnswered() ? "#9ca3af" : "#ffffff",
                    boxShadow: !isCurrentQuestionAnswered() ? "none" : "0 2px 8px rgba(59,130,246,0.25)",
                    "&:hover": {
                      background: !isCurrentQuestionAnswered() ? "#d1d5db" : "#2563eb",
                      boxShadow: !isCurrentQuestionAnswered() ? "none" : "0 4px 12px rgba(59,130,246,0.35)"
                    },
                    "&.Mui-disabled": {
                      background: "#d1d5db",
                      color: "#9ca3af"
                    }
                  }}
                >
                  {templatesData?.isEditing ? 'Update Assessment' : 'Review'}
                </Button>
              ) : isLastQuestionInSection() ? (
                <Button
                  onClick={handleNextSection}
                  disabled={!isCurrentQuestionAnswered()}
                  variant="contained"
                  endIcon={<ArrowForwardIosIcon />}
                  sx={{
                    textTransform: "none",
                    fontWeight: 700,
                    borderRadius: "10px",
                    px: 2.8,
                    py: 1.1,
                    background: !isCurrentQuestionAnswered() ? "#d1d5db" : "#3b82f6",
                    color: !isCurrentQuestionAnswered() ? "#9ca3af" : "#ffffff",
                    boxShadow: !isCurrentQuestionAnswered() ? "none" : "0 2px 8px rgba(59,130,246,0.25)",
                    "&:hover": {
                      background: !isCurrentQuestionAnswered() ? "#d1d5db" : "#2563eb",
                      boxShadow: !isCurrentQuestionAnswered() ? "none" : "0 4px 12px rgba(59,130,246,0.35)"
                    },
                    "&.Mui-disabled": {
                      background: "#d1d5db",
                      color: "#9ca3af"
                    }
                  }}
                >
                  Next Section
                </Button>
              ) : (
                <Button
                  onClick={handleNextQuestion}
                  disabled={!isCurrentQuestionAnswered()}
                  variant="contained"
                  endIcon={<ArrowForwardIosIcon />}
                  sx={{
                    textTransform: "none",
                    fontWeight: 700,
                    borderRadius: "10px",
                    px: 2.8,
                    py: 1.1,
                    background: !isCurrentQuestionAnswered() ? "#d1d5db" : "#3b82f6",
                    color: !isCurrentQuestionAnswered() ? "#9ca3af" : "#ffffff",
                    boxShadow: !isCurrentQuestionAnswered() ? "none" : "0 2px 8px rgba(59,130,246,0.25)",
                    "&:hover": {
                      background: !isCurrentQuestionAnswered() ? "#d1d5db" : "#2563eb",
                      boxShadow: !isCurrentQuestionAnswered() ? "none" : "0 4px 12px rgba(59,130,246,0.35)"
                    },
                    "&.Mui-disabled": {
                      background: "#d1d5db",
                      color: "#9ca3af"
                    }
                  }}
                >
                  Next Question
                </Button>
              )}
            </Box>
          </Box>
        </Card>
      </Box>
    </DashboardLayout>
  );
};

export default AssessmentPage;
